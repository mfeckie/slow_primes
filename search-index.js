var searchIndex = {};
searchIndex['slow_primes'] = {"items":[[0,"","slow_primes","Simplistic and relatively unoptimised handling of basic\ntasks around primes:"],[1,"Primes","","Stores information about primes up to some limit."],[1,"PrimeIterator","","Iterator over the primes stored in a sieve."],[3,"estimate_prime_pi","","Returns estimated bounds for Ï€(*n*), the number of primes less\nthan or equal to `n`."],[3,"estimate_nth_prime","","Gives estimated bounds for *p<sub>n</sub>*, the `n`th prime number,\n1-indexed (i.e. *p<sub>1</sub>* = 2, *p<sub>2</sub>* = 3)."],[3,"is_prime_miller_rabin","","Test if `n` is prime, using the deterministic version of the\nMiller-Rabin test."],[3,"as_perfect_power","","Returns integers `(y, k)` such that `x = y^k` with `k` maximised\n(other than for `x = 0, 1`, in which case `y = x`, `k = 1`)."],[3,"as_prime_power","","Return `Some((p, k))` if `x = p^k` for some prime `p` and `k >= 1`\n(that is, including when `x` is itself a prime)."],[10,"sieve","","Construct a `Primes` via a sieve up to at least `limit`.",0],[10,"upper_bound","","The largest number stored.",0],[10,"is_prime","","Check if `n` is prime, possibly failing if `n` is larger than\nthe upper bound of this Primes instance.",0],[10,"primes","","Iterator over the primes stored in this map.",0],[10,"factor","","Factorise `n` into (prime, exponent) pairs.",0],[10,"next","","",1],[10,"size_hint","","",1],[10,"next_back","","",1],[4,"Factors","","(prime, exponent) pairs storing the prime factorisation of a\nnumber."]],"paths":[[1,"Primes"],[1,"PrimeIterator"]]};
initSearch(searchIndex);
